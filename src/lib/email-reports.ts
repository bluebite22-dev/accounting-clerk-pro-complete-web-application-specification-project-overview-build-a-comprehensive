import nodemailer from "nodemailer";

// Email transporter configuration
// In production, use environment variables
const transporter = nodemailer.createTransport({
  host: process.env.SMTP_HOST || "smtp.example.com",
  port: parseInt(process.env.SMTP_PORT || "587"),
  secure: false,
  auth: {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASS,
  },
});

interface EmailOptions {
  to: string | string[];
  subject: string;
  html: string;
  attachments?: {
    filename: string;
    content: Buffer | string;
    contentType?: string;
  }[];
}

export async function sendReportEmail(options: EmailOptions): Promise<{ success: boolean; error?: string }> {
  try {
    const recipients = Array.isArray(options.to) ? options.to.join(", ") : options.to;

    await transporter.sendMail({
      from: process.env.EMAIL_FROM || '"Accounting Clerk Pro" <reports@accountingclerkpro.com>',
      to: recipients,
      subject: options.subject,
      html: options.html,
      attachments: options.attachments,
    });

    return { success: true };
  } catch (error: any) {
    console.error("Error sending email:", error);
    return { success: false, error: error.message };
  }
}

// Generate HTML email for report delivery
export function generateReportEmailHTML(options: {
  reportName: string;
  reportType: string;
  periodLabel: string;
  summary?: string;
  generatedAt: Date;
  downloadLink?: string;
}): string {
  const { reportName, reportType, periodLabel, summary, generatedAt, downloadLink } = options;

  return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>${reportName}</title>
    </head>
    <body style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;">
      <div style="background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%); padding: 30px; border-radius: 12px 12px 0 0;">
        <h1 style="color: white; margin: 0; font-size: 24px;">üìä ${reportName}</h1>
        <p style="color: rgba(255,255,255,0.9); margin: 10px 0 0 0;">${reportType}</p>
      </div>
      
      <div style="background: #f9fafb; padding: 30px; border-radius: 0 0 12px 12px; border: 1px solid #e5e7eb;">
        <p style="margin-top: 0;">Your scheduled report is ready for viewing.</p>
        
        <div style="background: white; padding: 20px; border-radius: 8px; margin: 20px 0; border: 1px solid #e5e7eb;">
          <p style="margin: 0 0 10px 0;"><strong>üìÖ Report Period:</strong> ${periodLabel}</p>
          <p style="margin: 0;"><strong>üïê Generated:</strong> ${generatedAt.toLocaleString()}</p>
        </div>

        ${summary ? `
        <div style="background: white; padding: 20px; border-radius: 8px; margin: 20px 0; border: 1px solid #e5e7eb;">
          <h3 style="margin-top: 0; color: #374151;">Summary</h3>
          ${summary}
        </div>
        ` : ""}

        ${downloadLink ? `
        <div style="text-align: center; margin: 30px 0;">
          <a href="${downloadLink}" style="background: #2563eb; color: white; padding: 14px 28px; text-decoration: none; border-radius: 8px; font-weight: 600; display: inline-block;">
            üì• Download Report
          </a>
        </div>
        ` : ""}

        <p style="color: #6b7280; font-size: 14px; margin-top: 30px; border-top: 1px solid #e5e7eb; padding-top: 20px;">
          This report was automatically generated by Accounting Clerk Pro. 
          To manage your report subscriptions, visit your dashboard settings.
        </p>
      </div>
    </body>
    </html>
  `;
}

// Process and send scheduled reports (would be called by cron job)
export async function processScheduledReports() {
  try {
    const { db } = await import("@/db");
    const { scheduledReports } = await import("@/db/schema");
    const { eq, and, lte } = await import("drizzle-orm");
    const { v4: uuidv4 } = await import("uuid");

    // Get reports that are due
    const now = new Date();
    const dueReports = await db.select()
      .from(scheduledReports)
      .where(and(
        eq(scheduledReports.isActive, true),
        lte(scheduledReports.nextRunAt, now)
      ));

    for (const report of dueReports) {
      try {
        // Generate report (would call report generation logic)
        const reportData = {
          name: report.name,
          type: report.reportType,
          generatedAt: now,
        };

        // Send to all recipients
        const recipients = JSON.parse(report.recipients as unknown as string);
        for (const recipient of recipients) {
          await sendReportEmail({
            to: recipient,
            subject: `[Report] ${report.name} - ${now.toLocaleDateString()}`,
            html: generateReportEmailHTML({
              reportName: report.name,
              reportType: report.reportType,
              periodLabel: "Current Period",
              generatedAt: now,
            }),
          });
        }

        // Update last run and calculate next run
        // (In production, use proper cron parsing)
        const nextRun = new Date(now);
        nextRun.setDate(nextRun.getDate() + 1); // Default to daily

        await db.update(scheduledReports)
          .set({
            lastRunAt: now,
            nextRunAt: nextRun,
            updatedAt: now,
          })
          .where(eq(scheduledReports.id, report.id));
      } catch (error) {
        console.error(`Error processing report ${report.id}:`, error);
      }
    }

    return { processed: dueReports.length };
  } catch (error) {
    console.error("Error processing scheduled reports:", error);
    throw error;
  }
}
